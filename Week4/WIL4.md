1.
301, 303 요청을 하였을때, 왜 httpstat.us 페이지의 메인으로 redirect될까?<br>

301 상태 코드는 요청한 리소스가 영구적으로 다른 URL로 이동되었음을 나타낸다.<br>
303 상태 코드는 요청한 리소스를 다른 URL에서 GET요청으로 가져오라는 의미이다.<br>
서버는 이 두 상태 코드와 함께 'Location'헤더를 사용해 새 URL을 제공하고 클라이언트는 해당 링크로 리다이렉션을 수행한다.<br>
따라서 httpstat.us의 메인 페이지로 리다이렉트되는 이유는 httpstat.us에서 301 혹은 303 요청 시 서버에서 Location 헤더에 httpstat.us의 메인 페이지 URL을 제공하기 때문이다.<br>

2.
401 요청을 하였을 때, 네트워크 탭의 상태를 보고 어떻게 인증해야 하는지 www-Authenticate 헤더를 기반으로 설명해보자.<br>

401 상태 코드는 클라이언트가 요청한 리소스에 대해 인증이 필요하다는 것을 의미한다. 이때 응답헤더의 WWW-Authenticate 헤더에 클라이언트가 인증을 시도할 수 있는 방법을 제공한다.<br>
인증 방식에는 Basic, Bearer, Digest 등이 있고<br>
각각 사용자 이름과 비밀번호를 base64로 인코딩한 값, 유효 토큰 값, 서버가 제공한 nonce 값을 포함하여 해시 함수로 변환한 값을 헤더에 추가하여 재요청한다.<br>

3.
Google에 “Hello”를 입력하여 결과물을 보고, 네트워크 요청 탭에서 캐시 관련 정보가 어디에 저장되어 있는지 분석하여 보자.<br>

네트워크 요청 탭에서 요청 항목을 선택 후 헤더 섹션을 선택하여 응답 헤더를 확인한다.<br>
이때 캐시 관련 헤더에는<br>
캐시 정책을 정의하는 Cache-Control<br>
리소스의 유효 기간을 나타내는 Expires<br>
리소스가 마지막으로 수정된 날짜를 나타내는 Last-Modified<br>
리소스의 고유한 식별자를 나타내는 ETag가 있다.<br>

4.
더 알고 싶은 상태코드를 직접 체험해보고, 해당 상태코드에서 진행한 요청 헤더, 응답 헤더를 직접 정리하여 분석해보자.<br>

413 Payload Too Large 코드는 요청 본문이 서버에서 정의한 제한보다 크다는 것을 의미한다. 개발자도구를 켜서 보면 요청 헤더 path 헤더 값이 엄청 길다.<br><br>

1.
떠오르는 의문을 해결해보자..<br>
캐시 유효 시간이 60초라고 가정해보자. 그럼 60초가 지날 때마다  캐시 데이터를
처음부터 네트워크를 통해 다시 받아하는 거 아닌가? 과연 이러한 방식이 올바를까?<br>
힌트 : 검증 헤더, 304 Not Modified, 헤더만 사용한 통신, 헤더 정보로 캐시의 메타 정보 재활용, 조건부 요청 헤더<br>

캐시 유효 시간이 지나면 무조건 처음부터 네트워크를 통해 리소스를 받아야 한다면 비효율적일 것이다.<br>
따라서 검증 헤더를 활용해 서버와 클라이언트 간의 캐시 데이터를 효율적으로 관리할 수 있다.<br>
주요 검증헤더에는 리소스의 고유한 식별자 역할을 하는 Etag, 리소스가 마지막으로 수정된 날짜와 시간을 나타내는 Last-Modified가 있다.<br>

클라이언트는 검증 헤더를 조건부 요청 헤더로 사용해 서버에 조건부 요청을 보낼 수 있다.<br>
주요 조건부 요청 헤더에는 이전에 받은 Etag 값을 사용하는 If-None-Match와 이전에 받은 Last-Modified 값을 사용하는 If-Modified-Since가 있다.<br>

서버는 클라이언트의 조건부 요청을 검사하여 리소스가 수정되지 않았다면 304 상태 코드를 반환하고 이 경우 응답은 리소스 본문을 포함하지 않고 클라이언트는 캐시된 데이터를 사용한다. 